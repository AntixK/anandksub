<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">

  
  <script>
    document.addEventListener("DOMContentLoaded", function () {
      renderMathInElement(document.body, {
        throwOnError: false,
        // output: "html",
        // customised options
        // • auto-render specific keys, e.g.:
        delimiters: [
          { left: '$$', right: '$$', display: true }, // block
          { left: '$', right: '$', display: false }, // Inline
          { left: "\begin{align}", right: "\end{align}", display: true }, // block
          { left: "\begin{aligned}", right: "\end{aligned}", display: true }, // block
        ],
        ignoredTags: [
          "pre",
          "code",
          "script",
          "style",
        ],
        macros: {
          "\\A": "\\mathbb{A}",
          "\\B": "\\mathbb{B}",
          "\\C": "\\mathbb{C}",
          "\\D": "\\mathbb{D}",
          "\\E": "\\mathbb{E}",
          "\\F": "\\mathbb{F}",
          "\\G": "\\mathbb{G}",
          "\\H": "\\mathbb{H}",
          "\\I": "\\mathbb{I}",
          "\\J": "\\mathbb{J}",
          "\\K": "\\mathbb{K}",
          "\\L": "\\mathbb{L}",
          "\\M": "\\mathbb{M}",
          "\\N": "\\mathbb{N}",
          "\\O": "\\mathbb{O}",
          "\\P": "\\mathbb{P}",
          "\\Q": "\\mathbb{Q}",
          "\\R": "\\mathbb{R}",
          "\\S": "\\mathbb{S}",
          "\\T": "\\mathbb{T}",
          "\\U": "\\mathbb{U}",
          "\\V": "\\mathbb{V}",
          "\\W": "\\mathbb{W}",
          "\\X": "\\mathbb{X}",
          "\\Y": "\\mathbb{Y}",
          "\\Z": "\\mathbb{Z}",

          "\\fA": "\\mathcal{A}",
          "\\fB": "\\mathcal{B}",
          "\\fC": "\\mathcal{C}",
          "\\fD": "\\mathcal{D}",
          "\\fE": "\\mathcal{E}",
          "\\fF": "\\mathcal{F}",
          "\\fG": "\\mathcal{G}",
          "\\fH": "\\mathcal{H}",
          "\\fI": "\\mathcal{I}",
          "\\fJ": "\\mathcal{J}",
          "\\fK": "\\mathcal{K}",
          "\\fL": "\\mathcal{L}",
          "\\fM": "\\mathcal{M}",
          "\\fN": "\\mathcal{N}",
          "\\fO": "\\mathcal{O}",
          "\\fP": "\\mathcal{P}",
          "\\fQ": "\\mathcal{Q}",
          "\\fR": "\\mathcal{R}",
          "\\fS": "\\mathcal{S}",
          "\\fT": "\\mathcal{T}",
          "\\fU": "\\mathcal{U}",
          "\\fV": "\\mathcal{V}",
          "\\fW": "\\mathcal{W}",
          "\\fX": "\\mathcal{X}",
          "\\fY": "\\mathcal{Y}",
          "\\fZ": "\\mathcal{Z}",

          "\\x": "\\times",
          "\\vA": "\\mathbf{A}",
          "\\vB": "\\mathbf{B}",
          "\\vC": "\\mathbf{C}",
          "\\vD": "\\mathbf{D}",
          "\\vE": "\\mathbf{E}",
          "\\vF": "\\mathbf{F}",
          "\\vG": "\\mathbf{G}",
          "\\vH": "\\mathbf{H}",
          "\\vI": "\\mathbf{I}",
          "\\vJ": "\\mathbf{J}",
          "\\vK": "\\mathbf{K}",
          "\\vL": "\\mathbf{L}",
          "\\vM": "\\mathbf{M}",
          "\\vN": "\\mathbf{N}",
          "\\vO": "\\mathbf{O}",
          "\\vP": "\\mathbf{P}",
          "\\vQ": "\\mathbf{Q}",
          "\\vR": "\\mathbf{R}",
          "\\vS": "\\mathbf{S}",
          "\\vT": "\\mathbf{T}",
          "\\vU": "\\mathbf{U}",
          "\\vV": "\\mathbf{V}",
          "\\vW": "\\mathbf{W}",
          "\\vX": "\\mathbf{X}",
          "\\vY": "\\mathbf{Y}",
          "\\vZ": "\\mathbf{Z}",

          "\\va": "\\mathbf{a}",
          "\\vb": "\\mathbf{b}",
          "\\vc": "\\mathbf{c}",
          "\\vd": "\\mathbf{d}",
          "\\ve": "\\mathbf{e}",
          "\\vf": "\\mathbf{f}",
          "\\vg": "\\mathbf{g}",
          "\\vh": "\\mathbf{h}",
          "\\vi": "\\mathbf{i}",
          "\\vj": "\\mathbf{j}",
          "\\vk": "\\mathbf{k}",
          "\\vl": "\\mathbf{l}",
          "\\vl": "\\mathbf{l}",
          "\\vm": "\\mathbf{m}",
          "\\vn": "\\mathbf{n}",
          "\\vo": "\\mathbf{o}",
          "\\vp": "\\mathbf{p}",
          "\\vq": "\\mathbf{q}",
          "\\vr": "\\mathbf{r}",
          "\\vs": "\\mathbf{s}",
          "\\vt": "\\mathbf{t}",
          "\\vu": "\\mathbf{u}",
          "\\vv": "\\mathbf{v}",
          "\\vw": "\\mathbf{w}",
          "\\vx": "\\mathbf{x}",
          "\\vy": "\\mathbf{y}",
          "\\vz": "\\mathbf{z}",

          "\\vmu": "\\boldsymbol \\mu",
          "\\vnu": "\\boldsymbol \\nu",
          "\\veps": "\\boldsymbol \\epsilon",
          "\\vtheta": "\\boldsymbol \\theta",
          "\\vomega": "\\boldsymbol \\omega",
          "\\vlambda": "\\boldsymbol \\lambda",
          "\\vzero": "\\mathbf{0}",
          "\\vone": "\\mathbf{1}",
          "\argmin": "\mathop{\mathrm{argmin}} \;",
          "\argmax": "\mathop{\mathrm{argmax}} \;",

        },
        globalGroup: true,
      });
    });
  </script>

  <link rel="stylesheet" href="/_libs/katex/katex.min.css">

  <script defer src="/_libs/katex/katex.min.js" crossorigin="anonymous"></script>
  <script defer src="/_libs/katex/auto-render.min.js" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>

  <!-- TEMML Instead of KATEX -->
  <!-- <link rel="stylesheet" href="/_libs/temml/Temml-Latin-Modern.css"> -->
  <!-- <script src="/_libs/temml/temml.min.js"></script> -->
  <!-- <script src="/_libs/temml/auto-render.min.js" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script> -->

  

  <!-- Link Style Sheets -->
  <link rel="stylesheet" href="/_css/ak.css">

  

  <title>A Cleverer Trick on top of the Reparametrization Trick</title>
</head>

<body>
  <!-- Site Header -->
  <header>
    <h1><a href="/">Anand K Subramanian</a><br><br></h1>
  </header>
  <!-- Navigation -->
  <nav class="navbar">
    <span><a href="/blog">Blog</a><span class="vl"></span></span>
    <span><a href="/notes">Notes</a> <span class="vl"></span></span>
    <span><a href="/art/">Art</a> <span class="vl"></span></span>
    <span><a href="/CV">CV</a> <span class="vl"></span></span>
    <span><a href="/tags">Tags</a>
  </nav>

  <!-- Article Info -->
  
  <p class="tags">
    <img class="icon-image" src="/assets/icons/bookmark.svg" alt="clock-icon">&ensp;<span
      class="pound">#</span>math <span
      class="pound">#</span>ml <span
      class="pound">#</span>gradient <span
      class="pound">#</span>deep-learning 
  </p>
  <p class="tags">
    <img class="icon-image" src="/assets/icons/calendar.svg" alt="clock-icon">&ensp;18 June 2020
  </p>
  <p class="tags">
    <img class="icon-image" src="/assets/icons/timer.svg" alt="clock-icon">&ensp;4 mins
  </p>
  

  <!-- Article Title -->
  <h1>A Cleverer Trick on top of the Reparametrization Trick</h1>
  <!-- Insert TLDR -->

  
  <p class="tldr">Implicit differentiation can lead to an efficient computation of the gradient of reparametrized samples.</p>
  

  <main>
    <p>   The famous <em>reparametrization trick</em> has been employed in estimating the gradients of samples from probability distributions by replacing an equivalent estimator that is <em>deterministic</em> and a <em>differential transformation</em> of a simple distribution.</p>
<p>The 2018 NeurIPS paper by <a href="https://arxiv.org/abs/1805.08498">Figurnov et.al</a> expounds the requirements of probability distributions on which the reparametrization trick can be used. For the reparametrization trick, the probability distribution, whose sample gradients are required, must satisfy at least one of the following conditions</p>
<ul>
<li>Has location-scale parametrization</li>
<li>Has a tractable inverse (cumulative distribution functions) CDF</li>
<li>Can be expressed as a deterministic differential transformation of other distributions satisfying the above two conditions.</li>
</ul>
<h3>Revisiting the Reparametrization Trick</h3>
<p>The reparametrization trick is used mainly in estimating the gradient of an expectation of a differentiable function $f(x)$ with respect to the parameters of the distribution $q(x; \theta)$ such that $x \sim q(x; \theta)$. In other words, the trick can be used to compute $\nabla_\theta E_{q(x;\theta)} [f(x)]$.</p>
<p>Here, $q(x;\theta)$ is come complex distribution that satisfies at least one of the conditions mentioned above.
Note that the main impediment to computing the gradient of the above expression directly is the non-differentiable step of sampling $x$ from $q(x;\theta)$.</p>
<p>Therefore, the trick is to rewrite the argument of the function $f$ as $f(s(x'))$ such that it is independent of the parameters of the distribution. In other words, since the sampling procedure is not differentiable, make the sampling procedure independent of the parameters so that the gradient for the sampling is not required. By re-writing the argument, the parameters get transferred to the function $f$ through $s(x')$.
When written as $f(s(x'))$, the $x'$ here is independent of the parameters of the distribution and hence no gradient of $x$ with respect to $\theta$ is required.</p>
<p>In general, if a sample $x$ can be written as a deterministic differentiable expression $s_{\theta}(x')$ where $x'$ is a sample that is independent of the parameters $\theta$</p>
<p>$$
\begin{aligned}
x &amp;= s_{\theta}(x'); \text{ where } x' \sim q(x')\\
\nabla_{\theta} E_{q(x;\theta)} [f(x)] &amp;= \nabla_{\theta} E_{q(x;\theta)} [f(s_{\theta}(x'))]
\end{aligned}
$$</p>
<p>The gradient of the above expression can thus, be computed (using chain-rule) as</p>
<p>$$
\begin{aligned}
\nabla_{\theta} E_{q(x;\theta)} [f(s_{\theta}(x'))] = E_{q(x;\theta)} [\nabla_{\theta}f(s_{\theta}(x'))] = E_{q(x;\theta)} [\nabla_{x}f(s_{\theta}(x')) \nabla_{\theta}s_{\theta}(x')]
\end{aligned}
$$</p>
<p>Now, if the distribution $q(x; \boldsymbol \theta)$ has a location and scale parameters (like the Gaussian distribution)
$\boldsymbol \theta = \{\mu, \sigma\}$, as then $s_\theta(x')$ can be a simple translation and scaling of the form</p>
<p>$$
x = s_{\boldsymbol \theta}(x') = (x' - \mu)/\sigma; \text{ where } x' \sim q(0,1)
$$</p>
<p>If the distribution $q(x; \theta)$  has a tractable inverse CDF $Q^{-1}$, then $x$ can be written as</p>
<p>$$
x = s_{\theta}(x') = Q^{-1}(x'); \text{ where } x' \sim U[0,1]
$$</p>
<p>It is also possible to use both of the above transformations in tandem, justifying the conditions presented above.</p>
<p>However, distributions like Gamma, Beta, Dirichlet distributions or even mixture distributions do not satisfy the above conditions and thus, the reparametrization trick cannot be used. Other techniques, addressing this limitation include approximating the intractable inverse CDF or using <em>score function</em> (gradient of the log likelihood). However, these produce gradients with relatively large variance. Large variance in such estimates affect the convergence of the training algorithm, and therefore, further variance-reduction techniques (like that of control-variates) are required. Often, the variance reduction techniques are problem-specific and cannot be used for a wide range of models.</p>
<h3>Implicit Reparametrization</h3>
<p>The paper proposes a clever technique for producing low-variance gradients using the reparametrization trick, that is applicable over a <em>large range</em> of probability distributions. Firstly, the difficulty arises from computing the gradient of the expression $s_{\theta}(x')$. For distributions like Gamma, the expression $s_{\theta}(x')$ usually follows their inverse CDF which is intractable. Therefore, computing the gradient becomes a huge problem. The task now is to find an efficient way to compute the gradient of the expression even for intractable $s_{\theta}$.</p>
<p>The key insight here is that the parameter-independent sample $x'$ can be written as</p>
<p>$$
x' = s_\theta^{-1}(x)
$$</p>
<p>Now, we can apply <em>implicit differentiation</em> technique to the above expression as follows-</p>
<p>$$
\begin{aligned}
\nabla s_\theta^{-1}(x) &amp;= \nabla x'\\
\nabla_{x}s_{\theta}^{-1}(x)\nabla_{\theta}x + \nabla_{\theta}s_{\theta}^{-1}(x)\nabla_{x}x &amp;= 0\\
\nabla_{\theta}x &amp;= -(\nabla_{x}s_{\theta}^{-1}(x))^{-1} \nabla_{\theta}s_{\theta}^{-1}(x)
\end{aligned}
$$</p>
<p>(Note that $\nabla$ represents total gradient and $\nabla_{\theta}$ represents gradient with respect to $\theta$.)
Therefore, through implicit differentiation, it is possible to find the gradient of the reparametrized samples $x$.</p>
<p>Now, observe that $\nabla_{\theta}x$ is simply $\nabla_{\theta}s_{\theta}(x')$. Since implicit differentiation yields the same result as that of the usual differentiation, the overall results for easier distributions like Gaussian are identical to the usual procedure. Furthermore, note that the above expression is only in terms of $s_{\theta}^{-1}$ which is essentially the CDF of complicated distributions like Gamma distribution. In such cases, numeric differentiation can be used to find the gradients.</p>
<p>In conclusion, using implicit differentiation, a generic method for finding the gradient of the reparametrized expression $s_{\theta}(x')$ can be determined. In cases where the CDF is intractable, the gradient can be directly found using numeric differentiation, as opposed to inverting the CDF and then computing the gradient in the usual reparametrization trick.</p>

  </main>

  <!-- Footer
  <div class="myfooter">
    &copy; 2024 Anand K Subramanian <span class=" vl"></span>
    License <span class="vl"></span>
    Design<span class="vl"></span>
    Built with SSG
    <span style="color: #e25555; font-size: 1.3rem;">&hearts;</span>
  </div> -->

  <div
    style="font-size:1.2rem; font-family: 'Overpass'; color: var(--c-4); text-align: center; margin-top: 6em; border-width: 75%; border-top: 1px solid var(--c-4); padding-top: 2em; margin-bottom: 4em;">
    &copy; 2024 Anand K Subramanian <span class="vl"></span>
    <a href="/license">License</a> <span class="vl"></span>
    <a href="/design">Design</a> <span class="vl"></span>
    Built with SSG
    <span style="color: #e25555; font-size: 24px;">&hearts;</span>
  </div>

  
</body>

</html>