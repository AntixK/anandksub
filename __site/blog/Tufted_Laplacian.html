<!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width, initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><script>
    document.addEventListener("DOMContentLoaded", function () {
      renderMathInElement(document.body, {
        throwOnError: false,
        // output: "html",
        // customised options
        // • auto-render specific keys, e.g.:
        delimiters: [
          { left: '$$', right: '$$', display: true }, // block
          { left: '$', right: '$', display: false }, // Inline
          { left: "\begin{align}", right: "\end{align}", display: true }, // block
          { left: "\begin{aligned}", right: "\end{aligned}", display: true }, // block
        ],
        ignoredTags: [
          "pre",
          "code",
          "script",
          "style",
        ],
        macros: {
          "\\A": "\\mathbb{A}",
          "\\B": "\\mathbb{B}",
          "\\C": "\\mathbb{C}",
          "\\D": "\\mathbb{D}",
          "\\E": "\\mathbb{E}",
          "\\F": "\\mathbb{F}",
          "\\G": "\\mathbb{G}",
          "\\H": "\\mathbb{H}",
          "\\I": "\\mathbb{I}",
          "\\J": "\\mathbb{J}",
          "\\K": "\\mathbb{K}",
          "\\L": "\\mathbb{L}",
          "\\M": "\\mathbb{M}",
          "\\N": "\\mathbb{N}",
          "\\O": "\\mathbb{O}",
          "\\P": "\\mathbb{P}",
          "\\Q": "\\mathbb{Q}",
          "\\R": "\\mathbb{R}",
          "\\S": "\\mathbb{S}",
          "\\T": "\\mathbb{T}",
          "\\U": "\\mathbb{U}",
          "\\V": "\\mathbb{V}",
          "\\W": "\\mathbb{W}",
          "\\X": "\\mathbb{X}",
          "\\Y": "\\mathbb{Y}",
          "\\Z": "\\mathbb{Z}",

          "\\fA": "\\mathcal{A}",
          "\\fB": "\\mathcal{B}",
          "\\fC": "\\mathcal{C}",
          "\\fD": "\\mathcal{D}",
          "\\fE": "\\mathcal{E}",
          "\\fF": "\\mathcal{F}",
          "\\fG": "\\mathcal{G}",
          "\\fH": "\\mathcal{H}",
          "\\fI": "\\mathcal{I}",
          "\\fJ": "\\mathcal{J}",
          "\\fK": "\\mathcal{K}",
          "\\fL": "\\mathcal{L}",
          "\\fM": "\\mathcal{M}",
          "\\fN": "\\mathcal{N}",
          "\\fO": "\\mathcal{O}",
          "\\fP": "\\mathcal{P}",
          "\\fQ": "\\mathcal{Q}",
          "\\fR": "\\mathcal{R}",
          "\\fS": "\\mathcal{S}",
          "\\fT": "\\mathcal{T}",
          "\\fU": "\\mathcal{U}",
          "\\fV": "\\mathcal{V}",
          "\\fW": "\\mathcal{W}",
          "\\fX": "\\mathcal{X}",
          "\\fY": "\\mathcal{Y}",
          "\\fZ": "\\mathcal{Z}",

          "\\x": "\\times",
          "\\vA": "\\mathbf{A}",
          "\\vB": "\\mathbf{B}",
          "\\vC": "\\mathbf{C}",
          "\\vD": "\\mathbf{D}",
          "\\vE": "\\mathbf{E}",
          "\\vF": "\\mathbf{F}",
          "\\vG": "\\mathbf{G}",
          "\\vH": "\\mathbf{H}",
          "\\vI": "\\mathbf{I}",
          "\\vJ": "\\mathbf{J}",
          "\\vK": "\\mathbf{K}",
          "\\vL": "\\mathbf{L}",
          "\\vM": "\\mathbf{M}",
          "\\vN": "\\mathbf{N}",
          "\\vO": "\\mathbf{O}",
          "\\vP": "\\mathbf{P}",
          "\\vQ": "\\mathbf{Q}",
          "\\vR": "\\mathbf{R}",
          "\\vS": "\\mathbf{S}",
          "\\vT": "\\mathbf{T}",
          "\\vU": "\\mathbf{U}",
          "\\vV": "\\mathbf{V}",
          "\\vW": "\\mathbf{W}",
          "\\vX": "\\mathbf{X}",
          "\\vY": "\\mathbf{Y}",
          "\\vZ": "\\mathbf{Z}",

          "\\va": "\\mathbf{a}",
          "\\vb": "\\mathbf{b}",
          "\\vc": "\\mathbf{c}",
          "\\vd": "\\mathbf{d}",
          "\\ve": "\\mathbf{e}",
          "\\vf": "\\mathbf{f}",
          "\\vg": "\\mathbf{g}",
          "\\vh": "\\mathbf{h}",
          "\\vi": "\\mathbf{i}",
          "\\vj": "\\mathbf{j}",
          "\\vk": "\\mathbf{k}",
          "\\vl": "\\mathbf{l}",
          "\\vl": "\\mathbf{l}",
          "\\vm": "\\mathbf{m}",
          "\\vn": "\\mathbf{n}",
          "\\vo": "\\mathbf{o}",
          "\\vp": "\\mathbf{p}",
          "\\vq": "\\mathbf{q}",
          "\\vr": "\\mathbf{r}",
          "\\vs": "\\mathbf{s}",
          "\\vt": "\\mathbf{t}",
          "\\vu": "\\mathbf{u}",
          "\\vv": "\\mathbf{v}",
          "\\vw": "\\mathbf{w}",
          "\\vx": "\\mathbf{x}",
          "\\vy": "\\mathbf{y}",
          "\\vz": "\\mathbf{z}",

          "\\vmu": "\\boldsymbol \\mu",
          "\\vnu": "\\boldsymbol \\nu",
          "\\veps": "\\boldsymbol \\epsilon",
          "\\vtheta": "\\boldsymbol \\theta",
          "\\vomega": "\\boldsymbol \\omega",
          "\\vlambda": "\\boldsymbol \\lambda",
          "\\vzero": "\\mathbf{0}",
          "\\vone": "\\mathbf{1}",
          "\argmin": "\mathop{\mathrm{argmin}} \;",
          "\argmax": "\mathop{\mathrm{argmax}} \;",
          "\\KL": "\\mathop{D_{\\mathrm{KL}}} \\;",

        },
        globalGroup: true,
      });
    });
  </script><link rel=stylesheet href=/_libs/katex/katex.min.css><script defer src=/_libs/algorithm/algotype.js crossorigin=anonymous></script><script defer src=/_libs/katex/katex.min.js crossorigin=anonymous>
  </script></script><script defer src=/_libs/katex/auto-render.min.js crossorigin=anonymous onload=renderMathInElement(document.body);></script><link rel=stylesheet href=/_css/ak.css><link rel=icon href=/assets/icons/favicon.ico type=image/x-icon><title>Extending Discrete Laplacian to Non-Manifold Structures</title></head><body><header><h1><a href=/ >Anand K Subramanian</a><br><br></h1></header><nav class=navbar><span><a href=/blog/ >Blog</a><span class=vl></span></span><span><a href=/notes/ >Notes</a> <span class=vl></span></span><span><a href=/art/ >Art</a> <span class=vl></span></span><span><a href=/CV>CV</a> <span class=vl></span></span><span><a href=/tags>Tags</a></nav><p class=tags><img class=icon-image src=/assets/icons/bookmark.svg alt=clock-icon>&ensp;<span class=pound>#</span>math <span class=pound>#</span>geometry <span class=pound>#</span>point-clouds <span class=pound>#</span>graph <span class=pound>#</span>mesh </p><p class=tags><img class=icon-image src=/assets/icons/calendar.svg alt=clock-icon>&ensp;25 November 2024 </p><p class=tags><img class=icon-image src=/assets/icons/timer.svg alt=clock-icon>&ensp;9 mins </p><h1>Extending Discrete Laplacian to Non-Manifold Structures</h1><p class=tldr>A simple way to construct the discrete Laplacian operator for messy point clouds and non-manifold meshes.</p><main><p>  Real-world 3D data can be messy. Point clouds, for instance, can be noisy, non-uniform, and can have varying densities. A given point cloud may not even follow a manifold. Similarly, 3D meshes can be complex and irregularly sampled; the triangulation may not be "regular" (skinny triangles or non-equilateral triangles), and may contain non-manifold edges and vertices. These may arise from the usual 3D data collection techniques such as LiDAR or 3D scanning. The scanning procedure itself may introduce non-manifold edges or vertices in the mesh.</p><p>When dealing with any 3D surface, a go-to operator is the Laplace-Beltrami operator, represented by $\Delta$. It is so fundamental that Laplace-Beltrami is to surface Geometry what the Fourier basis are for periodic functions. The functions on the (Riemannian) manifold can be decomposed into eigenfunctions of $\Delta$ on that manifold, similar to how periodic functions can be decomposed into Fourier series.</p><h2>Discretizing the Laplace-Beltrami Operator</h2><p>  When discretizing the Laplace-Beltrami operator over discrete structures like point clouds or meshes, we encounter problems - specifically we lose some important properties of the continuous Laplace-Beltrami operator.</p><p>When working on discrete structures, the following are some crucial properties we would like our Laplacian to have -</p><ol><li><strong>Symmetry</strong> - The Laplacian should be symmetric <em>i.e.</em> $w_{ij} = w_{ji}$, where $w_{ij}$ is the weight of the edge $ij$ in the mesh $\fG$ in the Laplacian matrix $L$.</li><li><strong>Locality</strong> - The weight $w_{ij} = 0$ for vertices $i$ and $j$ that do not share edges in the given mesh $\fG$. In other words, any change in the function at a distant point should not affect the <em>action</em> of the Laplacian in the local region. This results in a sparse Laplacian matrix.</li><li><strong>Positive</strong> - The weights $w_{ij} \geq 0$ for $i \neq j$. This ensures that the flow is from regions of higher potential to regions of lower potential and not vice-versa.</li><li><strong>Linear Precision</strong> - The Laplacian <em>action</em> $Lu$ must be zero whenever the mesh $\fG$ is line embedded into the Euclidean plane and $u$ is any linear function on the plane. This means that both the tangential and normal components of the Laplacian at a planar surface must be exactly zero. This is important for preserving the planar regions under parameterization.</li></ol><p>  The above properties are so chosen as to reflect those properties of the continuous Laplace-Beltrami operator that make it so useful in geometric processing. For example, the Linear precision property is highly useful in denoising and smoothing operations. The Symmetry and the Positive properties are the sufficient conditions for a positive semi-definite (PSD) Laplacian and one that satisfies the <em>Maximum Principle</em><sup id=fnref:max><a class=fnref href=#fndef:max>[1]</a></sup>. The Locality and Positive properties ensure that the discrete Laplacian follows the diffusion process just like the continuous Laplace-Beltrami operator $\Delta$.</p><p>Satisfying all the above syncretic properties is hard. In fact, Wardetzky et. al proved a No-Free-Lunch theorem<sup id=fnref:nfl><a class=fnref href=#fndef:nfl>[2]</a></sup> showing that it is impossible to satisfy all the above properties simultaneously for any discretized Laplacian. Imagine a world where DFTs do not satisfy the orthogonality property! The Horror!</p><p>  The <em>Cotan Laplacian</em> is a widely used approximation of discrete Laplacian. It is so chosen as it satisfies the Symmetric, Locality, and Linear Precision properties<sup id=fnref:cotan><a class=fnref href=#fndef:cotan>[3]</a></sup>. In fact, the Cotan Laplacian also satisfies another important property - its solution to the discrete Dirichlet problem converges to the solution of the smooth Dirichlet problem<sup id=fnref:dirichlet><a class=fnref href=#fndef:dirichlet>[4]</a></sup> involving $\Delta$. This makes Cotan Laplacian an indispensable choice for solving PDEs on meshes. Besides, it also works well on irregular vertex distributions in practice.</p><p>The general way to construct the Cotan Laplacian is to define a local cotan Matrix $C$ for each triangle $ijk$ in the mesh $$ C_{ijk} := \begin{bmatrix} w_{ki}+w_{ij} &amp; -w_{ij} &amp; -w_{ki} \\ -w_{ij} &amp; w_{ij}+w_{jk} &amp; -w_{jk} \\ -w_{ki} &amp; -w_{jk} &amp; w_{jk}+w_{ki} \end{bmatrix} $$</p><p>Where $w_{ij} = \frac{1}{2}\cot \theta_{i}^{jk}$. The entries of these local cotan matrices are then summed up into corresponding entries of a global laplacian $L \in \R^{|V| \x |V|}$. The associated <em>mass matrix</em> $B$ is a diagonal matrix defined as</p><p>$$ B_{ii} = \sum \frac{A_{ijk}}{3} $$</p><p>Where $A_{ijk}$ is the area of tringle incident of the vertex $i$.</p><p>The Cotan Laplacian, although widely applicable, does not satisfy the Positive property, even if it is PSD. This implies that the Maximum Principle is not satisfied by the Cotan Laplacian. A variation of the Cotan Laplacian is the <em>Intrinsic Laplacian</em>, which applies the <em>Intrinsic Delaunay Triangulation</em> over the given mesh and then constructs the Laplacian over this triangulated mesh.</p><p>A particular triangulation is <em>intrinsic Delaunay</em> if every interior edge $ij$ shared by triangles $ijk$ and $ijm$ satisfies the following condition</p><p>$$ \begin{aligned} \theta_k^{ij} + \theta_{m}^{ji} &amp;\leq \pi \\ \Rightarrow \cot \theta_k^{ij} + \cot \theta_{m}^{ji} &amp;\geq 0 \\ \end{aligned} $$</p><p>Where $\theta_k^{ij}$ is the interior angle at vertex $k$ of the triangle $ijk$. As evident from above, under this intrinsic triangulation, the Cotan Laplacian becomes Positive. Furthermore, any given triangulation can be converted to <em>intrinsic delaunay</em> via finite number of edge flips.</p><img style=width:80%;min-width:300px; src=/media/post_images/edge_flip.svg alt=Edge-Flips-Delaunay><p class=caption-text>Obtuse triangles lead to negative Cotan weights. A simple edge flip can resolve this issue and lead to intrinsic Delaunay triangulation with positive weights.</p><p>  As fated by the previously mentioned No-Free-Lunch theorem, the Intrinsic Laplacian loses the Locality property. The intrinsic Laplacian generally satisfies geometric locality - every vertex of a Delaunay triangulation is guaranteed to be connected to its closes neighbours. Although the it does not satisfy the <em>combinatorial</em> locality, the geometric locality is often sufficient for many applications. Nonetheless, the intrinsic Laplacian is not as sparse and may fail in cases where the local neighbourhood may be different from the input mesh.</p><h2>Extending the Laplacian to Non-Manifold Structures</h2><p>  Both the Cotan and its intrinsic variation are defined only for manifold structures. The intrinsic Laplacian requires at least an edge-manifold. So, the goal is to convert the given non-manifold to at least an edge-manifold. We can then use edge flips to get an intrinsic Delaunay triangulation, and finally the Cotan Laplacian.</p><br><div class=important><p>A quick refresher on the manifold property: An interior vertex $i$ is manifold if the boundary of all edges incident on $i$ form a loop or a path of edges. In simpler terms, the polygons containing each vertex must form a single "fan". An interior edge $ij$ is manifold if it is contained in exactly one or exactly two triangles. Or in other words, every edge must be contained in only two polygons or one polygon (no "fins"). The following figure illustrates the manifold conditions.</p><img style=width:70%;min-width:300px; src=/media/post_images/non-manifold.svg alt="Manifold Definition"></div><p>A recent paper by Sharp et. al.<sup id=fnref:sharp><a class=fnref href=#fndef:sharp>[5]</a></sup> introduces an elegant technique to convert the non-manifold mesh into edge-manifold mesh. They observe that the edge flips still work for cases where the mesh is edge-manifold but has non-manifold vertices. From this, the idea is then to add duplicate faces at edges where the mesh is non-manifold. This makes it an edge-manifold, but makes the interior vertices non-manifold. Yet, we can still perform edge flips on these duplicate faces (called tufted covers) to get a proper intrinsic Delaunay triangulation. Thus, by adding a tufted cover, any non-manifold edge can be converted to an edge-manifold as the previously shared face is now two separate faces.</p><img style=width:100%;min-width:400px; src=/media/post_images/tufted.svg alt="Tufted Laplacian procedure"><p>The important aspect of the above tufted cover <sup id=fnref:video><a class=fnref href=#fndef:video>[6]</a></sup> procedure is that the vertex set is preserved - we are only adding superficial faces (tufted cover) to the vertices to get an intrinsic Delaunay triangulation from which we can obtain the Cotan Laplacian. Recall that the Laplacian is a $|V| \x |V|$ matrix, where $|V|$ is the number of vertices.</p><p>  Therefore for given any triangulated mesh, manifold or not, it is possible to compute an <em>approximate</em> discrete Laplacian. A library for computing the tufted-cover Laplacian is available from the authors <a href=https://github.com/nmwsharp/robust-laplacians-py/tree/master>here</a>.</p><p>  The above procedure is more attractive for point clouds as traditional point cloud Laplacians try to approximate a local manifold using a $k$-NN graph. The neighbourhood size is usually chosen based on the local density of the point cloud, in-turn increasing the computational complexity. Furthermore, such sampling may result in loss of small or thin features in the point cloud, which are often found in real-world data. To reduce the computational complexity, a mesh Laplacian if often preferred - the point cloud is converted to a mesh and then the Laplacian is computed. The tufted-cover procedure improves upon this with just local triangulations<sup id=fnref:knn><a class=fnref href=#fndef:knn>[7]</a></sup> (may have irregular connectivity and non-manifold structures) over the input point cloud.</p><p>  As with any procedure, the result is only as good as its input data. The authors suggest that the input mesh/point cloud be free of topological noise, defective meshes, and isolated vertices before applying the tufted-cover procedure.</p><hr><p><table class=fndef id=fndef:max><tr><td class=fndef-backref><a href=#fnref:max>[1]</a></td><td class=fndef-content>The Maximum Principle is satisfied on a given manifold if the function on that manifold achieves maxima/minima at the boundary of the manifold. Physically, one may think of the heat diffusion over a metal rod where the temperature along the rod can never be the highest/lowest compared to the temperature at the ends of the rod.</td></tr></table></p><p><table class=fndef id=fndef:nfl><tr><td class=fndef-backref><a href=#fnref:nfl>[2]</a></td><td class=fndef-content>Wardetzky, Max, et al. "Discrete Laplace operators: no free lunch." Symposium on Geometry processing. Vol. 33. 2007. <a href=https://www.cs.columbia.edu/cg/pdfs/1180993110-laplacian.pdf>pdf</a&lt;></tr></table></p><p><table class=fndef id=fndef:cotan><tr><td class=fndef-backref><a href=#fnref:cotan>[3]</a></td><td class=fndef-content>The Cotan Laplacian has been derived by many authors in different contexts, the earliest of which goes back to 1949 by MacNeal. Refer to <em>Laplace-Beltrami: The Swiss Army Knife of Geometry Processing</em> by Justin Solomon, Keenan Crane, and Etienne Vouga. <a href=https://brickisland.net/DDGFall2017/wp-content/uploads/2017/11/SwissArmyLaplacian.pdf>Link</a&lt;></tr></table></p><p><table class=fndef id=fndef:dirichlet><tr><td class=fndef-backref><a href=#fnref:dirichlet>[4]</a></td><td class=fndef-content>The Dirichlet problem (closely related to the above Maximum Principle) is the solution of a specified PDE, given the values on the boundary of the domain. The solution to the Dirichlet problem involves the Laplace-Beltrami operator as $\Delta u = 0$. The usual physical interpretation is that, when a plate if heated/cooled at its boundary, the temperature of any interior point will reach <em>some</em> steady state, governed by the heat diffusion equation.</td></tr></table></p><p><table class=fndef id=fndef:sharp><tr><td class=fndef-backref><a href=#fnref:sharp>[5]</a></td><td class=fndef-content>Sharp, Nicholas, and Keenan Crane. "A laplacian for nonmanifold triangle meshes." Computer Graphics Forum. Vol. 39. No. 5. 2020. <a href=https://www.cs.cmu.edu/~kmcrane/Projects/NonmanifoldLaplace/index.html>Link</a&lt;></tr></table></p><p><table class=fndef id=fndef:video><tr><td class=fndef-backref><a href=#fnref:video>[6]</a></td><td class=fndef-content>Highly recommend Nicholas Sharp's <a href="https://www.youtube.com/watch?v=JY0kozIdIQo">presentation</a> where he shows a beautiful video of the tufted cover + intrinsic Delaunay triangulation (edge flip) process.</td></tr></table></p><p><table class=fndef id=fndef:knn><tr><td class=fndef-backref><a href=#fnref:knn>[7]</a></td><td class=fndef-content>For local triangulation, we still need to compute the $k$-NN graph. However, this is a fixed overhead to get a local triangulation as the actual Laplacian computation relies only the neighbourhood edges and vertices.</td></tr></table></p></main><div style="font-size:1.2rem; font-family: 'Overpass'; color: var(--c-4); text-align: center; margin-top: 6em; border-width: 75%; border-top: 1px solid var(--c-4); padding-top: 2em; margin-bottom: 4em;"> &copy; 2024 Anand K Subramanian <span class=vl></span><a href=/license>License</a> <span class=vl></span><a href=/design>Design</a> <span class=vl></span> Built with Kutti <span style="color: #e25555; font-size: 24px;">&hearts;</span></div></body></html>