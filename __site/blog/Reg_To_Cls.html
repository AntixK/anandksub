<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">

  
  <script>
    document.addEventListener("DOMContentLoaded", function () {
      renderMathInElement(document.body, {
        throwOnError: false,
        // output: "html",
        // customised options
        // • auto-render specific keys, e.g.:
        delimiters: [
          { left: '$$', right: '$$', display: true }, // block
          { left: '$', right: '$', display: false }, // Inline
          { left: "\begin{align}", right: "\end{align}", display: true }, // block
          { left: "\begin{aligned}", right: "\end{aligned}", display: true }, // block
        ],
        ignoredTags: [
          "pre",
          "code",
          "script",
          "style",
        ],
        macros: {
          "\\A": "\\mathbb{A}",
          "\\B": "\\mathbb{B}",
          "\\C": "\\mathbb{C}",
          "\\D": "\\mathbb{D}",
          "\\E": "\\mathbb{E}",
          "\\F": "\\mathbb{F}",
          "\\G": "\\mathbb{G}",
          "\\H": "\\mathbb{H}",
          "\\I": "\\mathbb{I}",
          "\\J": "\\mathbb{J}",
          "\\K": "\\mathbb{K}",
          "\\L": "\\mathbb{L}",
          "\\M": "\\mathbb{M}",
          "\\N": "\\mathbb{N}",
          "\\O": "\\mathbb{O}",
          "\\P": "\\mathbb{P}",
          "\\Q": "\\mathbb{Q}",
          "\\R": "\\mathbb{R}",
          "\\S": "\\mathbb{S}",
          "\\T": "\\mathbb{T}",
          "\\U": "\\mathbb{U}",
          "\\V": "\\mathbb{V}",
          "\\W": "\\mathbb{W}",
          "\\X": "\\mathbb{X}",
          "\\Y": "\\mathbb{Y}",
          "\\Z": "\\mathbb{Z}",

          "\\fA": "\\mathcal{A}",
          "\\fB": "\\mathcal{B}",
          "\\fC": "\\mathcal{C}",
          "\\fD": "\\mathcal{D}",
          "\\fE": "\\mathcal{E}",
          "\\fF": "\\mathcal{F}",
          "\\fG": "\\mathcal{G}",
          "\\fH": "\\mathcal{H}",
          "\\fI": "\\mathcal{I}",
          "\\fJ": "\\mathcal{J}",
          "\\fK": "\\mathcal{K}",
          "\\fL": "\\mathcal{L}",
          "\\fM": "\\mathcal{M}",
          "\\fN": "\\mathcal{N}",
          "\\fO": "\\mathcal{O}",
          "\\fP": "\\mathcal{P}",
          "\\fQ": "\\mathcal{Q}",
          "\\fR": "\\mathcal{R}",
          "\\fS": "\\mathcal{S}",
          "\\fT": "\\mathcal{T}",
          "\\fU": "\\mathcal{U}",
          "\\fV": "\\mathcal{V}",
          "\\fW": "\\mathcal{W}",
          "\\fX": "\\mathcal{X}",
          "\\fY": "\\mathcal{Y}",
          "\\fZ": "\\mathcal{Z}",

          "\\x": "\\times",
          "\\vA": "\\mathbf{A}",
          "\\vB": "\\mathbf{B}",
          "\\vC": "\\mathbf{C}",
          "\\vD": "\\mathbf{D}",
          "\\vE": "\\mathbf{E}",
          "\\vF": "\\mathbf{F}",
          "\\vG": "\\mathbf{G}",
          "\\vH": "\\mathbf{H}",
          "\\vI": "\\mathbf{I}",
          "\\vJ": "\\mathbf{J}",
          "\\vK": "\\mathbf{K}",
          "\\vL": "\\mathbf{L}",
          "\\vM": "\\mathbf{M}",
          "\\vN": "\\mathbf{N}",
          "\\vO": "\\mathbf{O}",
          "\\vP": "\\mathbf{P}",
          "\\vQ": "\\mathbf{Q}",
          "\\vR": "\\mathbf{R}",
          "\\vS": "\\mathbf{S}",
          "\\vT": "\\mathbf{T}",
          "\\vU": "\\mathbf{U}",
          "\\vV": "\\mathbf{V}",
          "\\vW": "\\mathbf{W}",
          "\\vX": "\\mathbf{X}",
          "\\vY": "\\mathbf{Y}",
          "\\vZ": "\\mathbf{Z}",

          "\\va": "\\mathbf{a}",
          "\\vb": "\\mathbf{b}",
          "\\vc": "\\mathbf{c}",
          "\\vd": "\\mathbf{d}",
          "\\ve": "\\mathbf{e}",
          "\\vf": "\\mathbf{f}",
          "\\vg": "\\mathbf{g}",
          "\\vh": "\\mathbf{h}",
          "\\vi": "\\mathbf{i}",
          "\\vj": "\\mathbf{j}",
          "\\vk": "\\mathbf{k}",
          "\\vl": "\\mathbf{l}",
          "\\vl": "\\mathbf{l}",
          "\\vm": "\\mathbf{m}",
          "\\vn": "\\mathbf{n}",
          "\\vo": "\\mathbf{o}",
          "\\vp": "\\mathbf{p}",
          "\\vq": "\\mathbf{q}",
          "\\vr": "\\mathbf{r}",
          "\\vs": "\\mathbf{s}",
          "\\vt": "\\mathbf{t}",
          "\\vu": "\\mathbf{u}",
          "\\vv": "\\mathbf{v}",
          "\\vw": "\\mathbf{w}",
          "\\vx": "\\mathbf{x}",
          "\\vy": "\\mathbf{y}",
          "\\vz": "\\mathbf{z}",

          "\\vmu": "\\boldsymbol \\mu",
          "\\vnu": "\\boldsymbol \\nu",
          "\\veps": "\\boldsymbol \\epsilon",
          "\\vtheta": "\\boldsymbol \\theta",
          "\\vomega": "\\boldsymbol \\omega",
          "\\vlambda": "\\boldsymbol \\lambda",
          "\\vzero": "\\mathbf{0}",
          "\\vone": "\\mathbf{1}",
          "\argmin": "\mathop{\mathrm{argmin}} \;",
          "\argmax": "\mathop{\mathrm{argmax}} \;",

        },
        globalGroup: true,
      });
    });
  </script>

  <link rel="stylesheet" href="/_libs/katex/katex.min.css">

  <script defer src="/_libs/katex/katex.min.js" crossorigin="anonymous"></script>
  <script defer src="/_libs/katex/auto-render.min.js" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>

  <!-- TEMML Instead of KATEX -->
  <!-- <link rel="stylesheet" href="/_libs/temml/Temml-Latin-Modern.css"> -->
  <!-- <script src="/_libs/temml/temml.min.js"></script> -->
  <!-- <script src="/_libs/temml/auto-render.min.js" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script> -->

  

  <!-- Link Style Sheets -->
  <link rel="stylesheet" href="/_css/ak.css">

  

  <title>Classification to Regression and Back</title>
</head>

<body>
  <!-- Site Header -->
  <header>
    <h1><a href="/">Anand K Subramanian</a><br><br></h1>
  </header>
  <!-- Navigation -->
  <nav class="navbar">
    <span><a href="/blog">Blog</a><span class="vl"></span></span>
    <span><a href="/notes">Notes</a> <span class="vl"></span></span>
    <span><a href="/art/">Art</a> <span class="vl"></span></span>
    <span><a href="/CV">CV</a> <span class="vl"></span></span>
    <span><a href="/tags">Tags</a>
  </nav>

  <!-- Article Info -->
  
  <p class="tags">
    <img class="icon-image" src="/assets/icons/bookmark.svg" alt="clock-icon">&ensp;<span
      class="pound">#</span>math <span
      class="pound">#</span>ml <span
      class="pound">#</span>code 
  </p>
  <p class="tags">
    <img class="icon-image" src="/assets/icons/calendar.svg" alt="clock-icon">&ensp;26 September 2024
  </p>
  <p class="tags">
    <img class="icon-image" src="/assets/icons/timer.svg" alt="clock-icon">&ensp;7 mins
  </p>
  

  <!-- Article Title -->
  <h1>Classification to Regression and Back</h1>
  <!-- Insert TLDR -->

  
  <p class="tldr">A trick to convert classification labels to regression targets and back.</p>
  

  <main>
    <p>  Don't ask me why, but what if you need to convert a simple multi-class classification problem into a regression problem? Usually, the other way is easier - converting continuous regression targets into classification is done using a simple binning. It is much more popular in Neural Networks (NNs) than classical ML models since NNs are generally better at classification than regression<sup id="fnref:1"><a class="fnref" href="#fndef:1">[1]</a></sup>.</p>
<p>But surely, it is an interesting problem to convert discrete classification labels to continuous regression targets and back, irrespective of the model. Let us try to formulate the problem.</p>
<blockquote>
<p>Given a dataset $\fD = \{(x_i, c_i)\}$ where $x_i$ is the input and $c_i$ is its corresponding class label, find a technique to convert it into a regression dataset $\{(x_i, y_i)\}$ with continuous target variable $y_i$.</p>
</blockquote>
<p>Now, any given discrete class label can be mapped onto a simplex. A simplex is just an $N$-dimensional triangle. So, a class label of 1 in a three class label system of $\{1,2, 3\}$ can be mapped to a simplex as $[1,0, 0]$ and the label 2 as $[0, 1, 0]$ - as in 3D, a unit equilateral triangle is the simplex. Similarly we can extend this idea to $N$ dimensions, where given $N$ classes $\{1, 2, \ldots, N\}$, the $i^{th}$ label will be represented on the simplex as a $N$-d vector with 1 at the $(N-i+1)^{th}$ position. But why a simplex? Well, simplex is the smallest possible form (polytope) where each label is uniquely identifiable. You may recall this simplex-mapping in ML as one-hot encoding.</p>
<img  style="width:50%;min-width:400px;"  src="/media/post_images/one-hot.svg" alt="One-Hot Encoding">

<p>The above encoding can be thought as each label existing on the non-origin vertex of the $N$-d unit-simplex. Which implies that the sum of the coordinates sum up to 1. We can then re-imagine them as a probability vector for the $i^{th}$ class. In other words, the simplex can be recast as logits.</p>
<p>Say, given a $N$-d one-hot encoding, how we map it to a $N$-d probability vector $\{[p_1, p_2, \ldots, p_N] \in \R^N | p_i \geq 0, \sum p_i = 1 \}$. Any procedure involving the conversion of discrete to continuous must have some relaxation or noise addition. In literature, it is sometimes called as <em>label smoothing</em>. Let us try to reuse the label smoothing used in say, the Inception V2 paper<sup id="fnref:2"><a class="fnref" href="#fndef:2">[2]</a></sup>.</p>
<p>$$
LS(\delta_i) = (1 - \gamma) \delta_i + \gamma \epsilon
$$</p>
<p>where $\delta_i$ is the one-hot vector of the $i^{th}$ class, $\epsilon \sim \fU$ is a uniform noise distribution over the $N$ classes, and $\gamma$ is the coefficient that controls the relaxation. Basically, given a uniform prior distribution over all classes, each label is jittered away from the vertex. This relaxed one-hot vector is now a point on the <em>probability simplex</em>.</p>
<img  style="width:30%;min-width:300px;"  src="/media/post_images/label-smooth.svg" alt="Label Smoothing">

<p>So, that's it? We have now a real-valued vector from the discrete class labels. Note that these vectors, although continuous, exists on the simplex. In other words, they are constrained to be within the simplex. Even if we use a regression loss, the optimizer needs account for this constraint. This is not so straight-forward<sup id="fnref:3"><a class="fnref" href="#fndef:3">[3]</a></sup>.</p>
<p>  Here's the most interesting part of the problem - one that motivated me to write this article. One can transform the probability simplex vector such that the resultant follows a Multivariate Normal (MVN) Distribution. That is, given the relaxed simplex vector $\delta_i$</p>
<p>$$
\begin{aligned}
y_i = \big [\log(\delta_i^1 / \delta_i^M), \log(\delta_i^2 / \delta_i^M), \ldots, \log(\delta_i^N / \delta_i^M) \big ] \sim \fN
\end{aligned}
$$</p>
<p>Where $\delta_i^j$ is the $j^{th}$ component of the $\delta_i$ vector, and $\delta_i^M$ is the $M^{th}$ component of $\delta_i$ chosen to the normalizer. This result is due to Aichison and Shen (1980)<sup id="fnref:4"><a class="fnref" href="#fndef:4">[4]</a></sup>.</p>
<p>Based on the above idea, a general class of log-ratio transforms were introduced to reparameterize probability simplexes on to MVN. The one caveat being that no logit should be zero. A more recent such log-ratio transform is the <em>isometric log-ratio transform</em> (ILR). This is a more sophisticated transform but the crux is still the log-ratio of the individual components. IRL uses the geometric mean of the simplex vector to normalize the simplex vector and projects the resultant log vector unto an orthogonal space.</p>
<p>$$
\begin{aligned}
p_i &amp;= \big [ \log(\delta_i^1 / g(\delta_i)), \ldots,  \log(\delta_i^N / g(\delta_i)) \big ]\\
y_i &amp;= V^T p_i  &amp;&amp; \color{OrangeRed} \text{(ILR)}
\end{aligned}
$$
Where $g(\delta_i)$ is the geometric mean of the vector $\delta_i$, and $V$ is some orthonormal basis matrix of size $N \times (N-1)$. The resultant $y_i$ is a real-valued continuous, unconstrained, normal-distributed variable (of $N-1$ dimensions), which can be directly used for regression problems.</p>
<p>  Even more fascinating is that the procedure is completely reversible. The reverse operation is to directly map the variables back to the simplex space (inverse  orthogonal transformation) and undo the log-ratio transformation via a simple softmax. This yields the relaxed logits from which the labels can be determined losslessly. Note that even the binning operation to convert regression to classification is lossy as we cannot completely recover the value from the predicted bin.</p>
<h3>Code</h3>
<pre><code class="language-python">import numpy as np
from scipy.stats import gmean    # geometric mean
from scipy.linalg import helmert # For orthogonal matrix
from scipy.special import softmax

def label_to_continuous(labels, num_classes:int, gamma:float = 0.3):
    """
    Transforms the given labels into a set of
    continuous, unconstrained normal-distributed variables
    of dimension num_classes-1.
    """
    # One hot encoding
    delta = np.eye(num_classes)[labels]

    # Relaxation (epsilon = 1 / num_classes)
    delta = (1.0 - gamma) * delta +  gamma * np.ones_like(delta) / num_classes

    # Compute log ratios
    log_ratios = np.log(delta / gmean(delta, axis=-1).reshape(-1,1))

    # orthogonal basis
    V = helmert(num_classes, full=True)[1:]
    # Sanity check
    assert np.allclose(V @ V.T, np.eye(N-1))

    return log_ratios @ V.T

def continuous_to_label(y, num_classes:int):
    """
    Inverts the given set of continuous variables back
    to discrete labels.
    """
    V = helmert(num_classes, full=True)[1:]
    # Get log ratios
    lr = y @ V

    # Invert log ratios
    delta = softmax(lr)

    # Compute labels
    return np.argmax(delta, -1)

</code></pre>
<h2>But Why Tho?</h2>
<p>  Well, the paper<sup id="fnref:5"><a class="fnref" href="#fndef:5">[5]</a></sup> that proposed this idea, applied it to instances where the labels are noisy. Since, regression problems have a much more robust techniques for dealing with such issues (like separating noise form the signal), many noisy-label classification problems can be improved using this technique.</p>
<p>Another idea, again proposed by the first author Erik Englesson in a talk, is to apply to Gaussian Process classification. GP classification is intractable, and relies on Laplace approximation. This could also be a potential idea to map the classes to regression targets, perform GP regression, and map it back to discrete labels.</p>
<p>In any case, the idea of a simple log-ratio reparameterization to yield normal-distributed variables was quite fascinating. And that is enough for me!</p>
<hr />

        <p><table class="fndef" id="fndef:1">
            <tr>
                <td class="fndef-backref"><a href="#fnref:1">[1]</a></td> 
                <td class="fndef-content">Pose estimation, and object detection models (both using regression losses) do work well in practice, but generally for lower dimensional regression problems, NNs do not work well. They are better at classification. NNs using regression losses (say, MSE or NLL) work well when the dimensionality is high (MSE between images / large tensors). In fact, there's some research trying to understand why this is the case - based on the distribution of regression targets. See <a href="https://arxiv.org/abs/2308.10603">A step towards understanding why classification helps regression</a> and <a href="https://arxiv.org/abs/2203.16427">Balanced MSE for Imbalanced Visual Regression</a>.</td>
            </tr>
        </table></p>
        

        <p><table class="fndef" id="fndef:2">
            <tr>
                <td class="fndef-backref"><a href="#fnref:2">[2]</a></td> 
                <td class="fndef-content">ArXiv Link: <a href="https://arxiv.org/abs/1512.00567">Rethinking the Inception Architecture for Computer Vision</a>.</td>
            </tr>
        </table></p>
        

        <p><table class="fndef" id="fndef:3">
            <tr>
                <td class="fndef-backref"><a href="#fnref:3">[3]</a></td> 
                <td class="fndef-content">The above relaxed vectors may be assumed to follow the Dirichlet distribution, as it is tractable. But there is an easier way.</td>
            </tr>
        </table></p>
        

        <p><table class="fndef" id="fndef:4">
            <tr>
                <td class="fndef-backref"><a href="#fnref:4">[4]</a></td> 
                <td class="fndef-content">More formally, Aitchison introduced a family of distributions over the probability simplex - Logistic Normal distribution - that is easier to work with than conventional Dirichlet distribution. Furthermore, he also showed that these Logistic-Normal distributions are closer to the Dirichlet distribution in terms of KL divergence. Further reference: Aitchison J and Shen SM (1980) <em>Logistic-normal distributions. Some properties and uses</em>. Biometrika 67(2), 261–272.</td>
            </tr>
        </table></p>
        

        <p><table class="fndef" id="fndef:5">
            <tr>
                <td class="fndef-backref"><a href="#fnref:5">[5]</a></td> 
                <td class="fndef-content">Englesson, Erik, and Hossein Azizpour. <em>Robust classification via regression for learning with noisy labels.</em> ICLR 2024, Vienna, 2024. <a href="https://openreview.net/forum?id=wfgZc3IMqo">OpenReview Link</a</td>
            </tr>
        </table></p>
        

  </main>

  <!-- Footer
  <div class="myfooter">
    &copy; 2024 Anand K Subramanian <span class=" vl"></span>
    License <span class="vl"></span>
    Design<span class="vl"></span>
    Built with SSG
    <span style="color: #e25555; font-size: 1.3rem;">&hearts;</span>
  </div> -->

  <div
    style="font-size:1.2rem; font-family: 'Overpass'; color: var(--c-4); text-align: center; margin-top: 6em; border-width: 75%; border-top: 1px solid var(--c-4); padding-top: 2em; margin-bottom: 4em;">
    &copy; 2024 Anand K Subramanian <span class="vl"></span>
    <a href="/license">License</a> <span class="vl"></span>
    <a href="/design">Design</a> <span class="vl"></span>
    Built with SSG
    <span style="color: #e25555; font-size: 24px;">&hearts;</span>
  </div>

  
  <script src="/_libs/highlight/highlight.min.js"></script>
  <script>hljs.highlightAll(); hljs.configure({ tabReplace: '    ' });</script>
  <link rel="stylesheet" href="/_libs/highlight/decaf.css">

  <script src="/_libs/clipboard/clipboard.min.js"></script>
  <script>
    (function () {

      // Get the elements.
      // - the 'pre' element.
      // - the 'div' with the 'paste-content' id.

      var pre = document.getElementsByTagName('pre');

      // Add a copy button in the 'pre' element.
      // which only has the className of 'language-'.

      for (var i = 0; i < pre.length; i++) {
        var isLanguage = pre[i].children[0].className.indexOf('language-');

        if (isLanguage === 0) {
          var button = document.createElement('button');
          button.className = 'copy-button';
          button.textContent = 'Copy';

          pre[i].appendChild(button);
        }
      };

      // Run Clipboard

      var copyCode = new Clipboard('.copy-button', {
        target: function (trigger) {
          return trigger.previousElementSibling;
        }
      });

      // On success:
      // - Change the "Copy" text to "Copied".
      // - Swap it to "Copy" in 2s.
      // - Lead user to the "contenteditable" area with Velocity scroll.

      copyCode.on('success', function (event) {
        event.clearSelection();
        event.trigger.textContent = 'Copied';
        window.setTimeout(function () {
          event.trigger.textContent = 'Copy';
        }, 2000);

      });

      // On error (Safari):
      // - Change the  "Press Ctrl+C to copy"
      // - Swap it to "Copy" in 2s.

      copyCode.on('error', function (event) {
        event.trigger.textContent = 'Press "Ctrl + C" to copy';
        window.setTimeout(function () {
          event.trigger.textContent = 'Copy';
        }, 5000);
      });

    })();
  </script>
  
</body>

</html>